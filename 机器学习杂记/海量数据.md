# 1. top k

> 10亿个数中找出最大的k个数。

## 1.1 最小堆

先用前k个数字建立最小堆，之后的数字与堆顶比较。

如果比堆顶大，堆顶元素出堆，新元素入堆。

```cpp
HeadAdjust(vector<int> L, int start, int end){
    int e, idx;
    e = L[start]
    for(idx = 2 * start; idx < m; idx *= 2){
        if(j+1 <= m && L[j] < L[j+1])
        	j+=1;
        if(e > s[j])
        	break;
        L[s] = s[j];
        s = j;
    }
    L[s] = e;
}
```

# 1.2 加入分治

1. 将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的10000个，最后在剩下的100*10000个数据里面找出最大的10000个。 
2. 100万个数据里面查找最大的10000个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于10000个，就在小的那堆里面快速排序一次，找第10000-n大的数字；递归以上过程，就可以找到第1w大的数。参考上面的找出第1w大数字，就可以类似的方法找到前10000大数字了。此种方法需要每次的内存空间为10^6*4=4MB，一共需要101次这样的比较。 

## 1.3 加入位运算

从最高位开始比较，代替直接比较，硬件友好型。

