# 0. 面试题

转载 CSDN侠 https://blog.csdn.net/qq_22222499/article/details/79060495

## 1.事务四大特性 

原子性，要么执行，要么不执行 
隔离性，所有操作全部执行完以前，其它会话不能看到过程 
一致性，事务前后，数据总额一致 
持久性，一旦事务提交，对数据的改变就是永久的

## 2.数据库隔离级别

* 脏读(事务没提交，提前读取)：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。 

* 不可重复读(读有问题)：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读 

* 幻读（写有问题）和串行读

  ```mysql
  T1：select * from users where id = 1;
  T2：insert into users(id, name) values (1, 'big cat');
  T1：insert into users(id, name) values (1, 'big cat');
  ```

  * 在 RR 隔离级别下，1、2 是会正常执行的，3 则会报错主键冲突，对于 T1 的业务来说是执行失败的。这里 T1 就是发生了幻读，因为T1读取的数据状态并不能支持他的下一步的业务，见鬼了一样。

  * 在 Serializable 隔离级别下，1 执行时是会隐式的添加 gap 共享锁的，从而 2 会被阻塞，3 会正常执行。对于 T1 来说业务是正确的，成功的扼杀了扰乱业务的T2，对于T1来说他读取的状态是可以拿来支持业务的。


| 隔离级别 | 读数据一致性 | 脏读 | 不可重复读 | 幻读 |
| :------: | :----------: | :--: | :--------: | :--: |
| 未提交读 |   最低级别   |  Y   |     Y      |  Y   |
| 已提交读 |    语句级    |  N   |     Y      |  Y   |
|  事务级  |    事务级    |  N   |     N      |  Y   |
|  串行化  |   最高级别   |  N   |     N      |  N   |

### 3 数据库中的锁：

锁的种类：

按照锁的内容上分为：表锁，页锁，行锁。InnoDB支持行锁，MyIsam支持表锁，BerkeleyDBA支持页锁。不同的粒度

按照锁的性质分可以分为：共享锁（读锁或S锁）,独占锁（写锁，排它锁）（X锁），更新锁（U锁）（意向锁）

当执行select时候，加共享锁，当insert update delete等操作时，加排它锁。更新锁首先对数据对象作更新锁锁定，这样数据将不能被修改，但可以读取。等到SQL Server确定要进行更新数据操作时，他会自动将更新锁换为独占锁，当对象上有其他锁存在时，无法对其加更新锁。

意向锁是为了提高封锁子系统的效率。该封锁子系统支持多种封锁粒度。原因是:在多粒度封锁方法中一个数据对象可能以两种方式加锁 ― 显式封锁和隐式封锁。

数据库引擎使用意向锁来保护锁层次结构的底层资源，以防止其他事务对自己锁住的资源造成伤害，提高锁冲突检测性能。例如，当读取表里的页面时，在请求页共享锁（S锁）之前，事务在表级请求共享意向锁。这样可以防止其他事务随后在表上获取排他锁（X锁），修改整个表格。意向锁可以提高性能，因为数据库引擎仅在表级检查意向锁，确定事务是否能安全地获取该表上的锁，而不需要检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。

## 4.MYSQL的两种存储引擎区别 

MYISAM 不支持事务，不支持外键，表锁，插入数据时，锁定整个表，查表总行数时，不需要全表扫描 
INNODB 支持事务，支持外键，行锁，查表总行数时，全表扫描

## 5.索引有B+索引和hash索引 

hash索引，等值查询效率高， 
不能排序 
不能进行范围查询

B+索引 
数据有序 
范围查询

## 6.B+索引数据结构，和B树的区别

1.单一节点存储更多的元素，B+树空间利用率更高，使得查询的IO次数更少。 
2.所有查询都要查找到叶子节点，查询性能稳定。 
3.所有叶子节点形成有序链表，便于范围查询

#### B树的结构

1.根结点至少有两个子女。 
2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m 
3.每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m 
4.所有的叶子结点都位于同一层。 
5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划 
k的大小取决于磁盘页的大小，主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常， 此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。

#### B+树具体实现 

一个m阶的B+树具有如下几个特征： 
1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 
2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 
3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素

#### 为什么使用B-/+Tree 

索引查找过程中就要产生磁盘I/O消耗,主要看IO次数，和磁盘存取原理有关。 
根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理， 
将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入 
局部性原理与磁盘预读

## 7. InnoDB索引和MyISAM索引的区别： 

一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。 
二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。



## 7 .索引的底层实现（B+树，为何不采用红黑树，B树）

增加，删除，红黑树会进行频繁的调整，来保证红黑树的性质，浪费时间 
B树，查询性能不稳定，查询结果高度不致， 
B树，每个结点保存指向真实数据的指印，相比B+树每一层每屋存储的元素更多，显得更高一点。

## 8.聚集索引和非聚集索引区别

聚集索引，数据按索引顺序存储，中子结点存储真实的物理数据 
非聚集索引，存储指向真正数据行的指针

## 9.索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）

索引最大的好处是提高查询速度， 
缺点是更新数据时效率低，因为要同时更新索引 
对数据进行频繁查询进建立索引，如果要频繁更改数据不建议使用索引。

## 数据库的优化

（一条sql中能使用一个索引，多个索引会自动选择最优的索引,从sql语句优化和索引两个部分回答） 
原则1.sql尽量使用索引 
2.对sql语句优化 
子查询变成left join 
limit 分布优化，先利用ID定位，再分页 
or条件优化，多个or条件可以用union all对结果进行合并（union all结果可能重复） 
不必要的排序 
where代替having,having 检索完所有记录，才进行过滤 
避免嵌套查询 
对多个字段进行等值查询时，联合索引

###索引最左前缀问题 

如果对三个字段建立联合索引，如果第二个字段没有使用索引，第三个字段也使用不到索引了。 

### 索引分类，索引失效条件 

普通索引：最基本的索引，没有任何限制 
唯一索引：与”普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值。 
主键索引：它是一种特殊的唯一索引，不允许有空值。 
全文索引：针对较大的数据，生成全文索引很耗时好空间。 
组合索引：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则 
失效条件 
条件是or,如果还想让or条件生效，给or每个字段加个索引 
like查询，以%开发 
内部函数 
对索引列进行计算 
is null不会用，is not null 会用

## 数据库的主从复制 

### 默认异步复制

容易造成主库数据和从库不一致 
一个数据库为Master,一个数据库为slave,通过Binlog日志 
slave两个线程，一个线程去读master binlog日志，写到自己的中继日志 
一个线程解析日志，执行sql 
master启动一个线程 
给slave传递binlog日志

### 半同步复制 

只有把master发送的binlog日志写到slave的中继日志，这时主库 
才返回操作完成的反馈，性能有一定降低

### 并行复制 

slave 多个线程去请求binlog日志

### long_query怎么解决 

设置参数，开启慢日志功能，得到耗时超过一定时间的sql

### varchar和char的使用场景 

用来存储字符 
varchar适用字符长度经常变的 
char适用字符长度固定的

### 数据库连接池的作用 

维护一定数量的连接，减少创建连接的时间 
更快的响应时间 
统一的管理

### 分库分表，主从复制，读写分离 

读写分离，读从库，写主库 
spring配置两个数据库，通过AOP（面向切面编程），在写或读方法前面进行判断得到动态切换数据源。

### 数据库三范式 

1NF 属性不可分 
2NF 非主键属性，完全依赖于主键属性 
3NF 非主键属性无传递依赖

### 关系型数据库和非关系型数据库区别 

数据库 
类型 特性 
关系型数据库mysql 1、关系型数据库，是指采用了关系模型来组织数据的数据库, 
2.关系型数据库的最大特点就是事务的一致性；

优点
1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；
2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；
3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；
4、支持SQL，可用于复杂的查询。 
缺点
1、为了维护一致性所付出的巨大代价就是其读写性能比较差；
2、固定的表结构；
3、不支持高并发读写需求；
4、不支持海量数据的高效率读写；

非关系型数据库 特性 
HBase 1、使用键值对存储数据； 

### 分布式； 

优点 
无需经过sql层的解析，读写性能很高 
基于键值对，数据没有耦合性，容易扩展 
存储数据的格式：nosql的存储格式是key,value形式 
缺点 
不支持事务 
不提供sql支持

### 数据库中join的inner join, outer join, cross join 

| 语句                  | 含义                                                         |
| --------------------- | ------------------------------------------------------------ |
| A inner join B        | A,B的交集                                                    |
| A left join B         | 选出A的所有记录，B表中没有的以null 代替                      |
| cross join (笛卡尔积) | A中的每一条记录和B中的每一条记录生成一条记录 例如A中有4条，B中有4条，cross join 就有16条记录 |
| outer join 全连       | 选出A，B的所有记录，没有字段用null 代替                      |

### 哪些锁,select时怎么加排它锁 

乐观锁,自己实现，通过版本号 
悲观锁：共享锁，多个事务，只能读不能写，加 lock in share mode 
排它锁，一个事务，只能写，for update 
行锁 
表锁 
25.死锁怎么解决 
找到进程号，kill 进程

### 最左匹配原则 

最左匹配原则是针对索引的 

当一个表有多条索引可走时,  Mysql  根据查询语句的成本来选择走哪条索引, 联合索引的话, 它往往计算的是第一个字段(最左边那个), 这样往往会走错索引. 如: 
索引Index_1(Create_Time, Category_ID), Index_2(Category_ID) 

如果每天的数据都特别多, 而且有很多category, 但具体每个category的记录不会很多.

当查询SQL条件为select …where create_time ….and category_id=..时, 很可能不走索引Index_1, 而走索引Index_2, 导致查询比较慢.

解决办法是将索引字段的顺序调换一下.

# 1.索引详细介绍

## 1.1 索引的意义

对要查询的字段建立索引其实就是把该字段按照一定的方式排序；建立的索引只对该字段有用，如果查询的字段改变，那么这个索引也就无效了

## 1.2 优缺点

### 1.2.1 优点

1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 
2. 可以大大加快数据的检索速度，这也是创建索引的最主要的原因
3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义
4. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
5. 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

### 1.2.2 代价

1. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大
3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

## 1.3 不适用情况：

1. 进行全表扫描了
2. 对**非**唯一的字段，例如“性别”这种大量重复值的字段
3. 对于记录比较少的表，因为索引是需要存储空间的
4. 当修改性能远远大于检索性能时，不应该创建索引。每次执行update/insert/delete字段的索引都必须重新计算更新。
5. 对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

## 1 .4 适用情况

1. 经常需要搜索的列上，可以加快搜索的速度
2. 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构
3. 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度
4. 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的
5. 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 
6. 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 

## 1.5 创建索引的方法 

1. 直接创建索引，例如使用CREATE INDEX语句或者使用创建索引向导

   1. 可以定制创建出符合自己需要的索引。
   2. 使用许多选项，例如指定数据页的充满度、进行排序、整理统计信息等，这样可以优化索引。
   3. 可以指定索引的类型、唯一性和复合 性，也就是说，既可以创建聚簇索引，也可以创建非聚簇索引
   4. 既可以在一个列上创建索引，也可以在两个或者两个以上的列上创建索引。

   

2. 间接创建索引，例如在表中定义主键约束或者唯一性键约束时，同时也创建了索引。

   1. 当使用约束 创建索引时，索引的类型和特征基本上都已经确定了。
   2. 在创建主键约束时，系统自动创建 了一个唯一性的聚簇索引。在物理结构上，与主键约束相对应的结构是唯一性的聚簇索引。
   3. 同样，在创建唯一性键约束时，也同时创建了索引，这种索引则是唯一性的非聚簇索引。

## 1.6 索引的特征

### 1.6.1 唯 一性索引

唯 一性索引保证在索引列中的全部数据是唯一的，不会包含冗余数据。如果表中已经有一个主键约束或者唯一性键约束，那么当创建表或者修改表时，SQL Server自动创建一个唯一性索引。然而，如果必须保证唯一性，那么应该创建主键约束或者唯一性键约束，而不是创建一个唯一性索引。

### 1.6.2 复合索引 

复合索引就是一个索引创建在两个列 或者多个列上。

应该考虑这些规则：

1. 最多可以把16个列合并 成一个单独的复合索引，构成复合索引的列的总长度不能超过900字节
2. 在复合索引中，所有的列必须来自同一个表中，不能跨 表建立复合列
3. 在复合索引中，按照从左到右是重要性进行索引，原则上，应该首先定义最唯一的列

### 1.6.3 聚簇索引与非聚簇索引适用情况

| 动作               | 使用聚簇索引 | 使用非聚簇索引 |
| ------------------ | ------------ | -------------- |
| 列经常被分组排序   | 应           | 应             |
| 返回某范围内的数据 | 应           | 不应           |
| 一个或极少不同值   | 不应         | 不应           |
| 小数目的不同值     | 应           | 不应           |
| 大数目的不同值     | 不应         | 应             |
| 频繁更新的列       | 不应         | 应             |
| 外键列             | 应           | 应             |
| 主键列             | 应           | 应             |
| 频繁修改索引列     | 不应         | 应             |

## 1.7 索引优化策略

引用网址： https://blog.csdn.net/shen_gang/article/details/18924519

1. 缺省情况下建立的索引是非聚簇索引，但有时它并不是最佳的。在非群集索引下，数据在物理上随机存放在数据页上。
2. 合理的索引设计要建立在对各种查询的分析和预测上。一般来说：  
   1. 有大量重复值、且经常有范围查询（ > ,< ，> =,< =）和order by、group by发生的列，可考  虑建立群集索引
   2. 经常同时存取多列，且每列都含有重复值可考虑建立组合索引
   3. 组合索引要尽量使关键查询形成索引覆盖，其前导列一定是使用最频繁的列
   4. 索引虽有助于提高性能但不是索引越多越好，恰好相反过多的索引会导致系统低效。用户在表中每加进一个索引，维护索引集合就要做相应的更新工作。 
3.   ORDER BY和GROPU BY使用ORDER BY和GROUP BY短语，任何一种索引都有助于SELECT的性能提高。
4. 多表操作在被实际执行前，查询优化器会根据连接条件，列出几组可能的连接方案并从中找出系统开销最小的最佳方案。连接条件要充份考虑带有索引的表、行数多的表；内外表的选择可由公式：外层表中的匹配行数*内层表中每一次查找的次数确定，乘积最小为最佳方案。
5. 任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。   
6. IN、OR子句常会使用工作表，使索引失效。如果不产生大量重复值，可以考虑把子句拆开。拆开的子句中应该包含索引。
7.  Sql的优化原则2： 
   1.  只要能满足你的需求，应尽可能使用更小的数据类型：例如使用MEDIUMINT代替INT 
   2. 尽量把所有的列设置为NOT NULL，如果你要保存NULL，手动去设置它，而不是把它设为默认值。  
   3. 尽量少用VARCHAR、TEXT、BLOB类型 
   4. 如果你的数据只有你所知的少量的几个。最好使用ENUM类型  

## 1.7 聚簇索引的体系结构

索 引的结构类似于树状结构，树的顶部称为叶级，树的其它部分称为非叶级，树的根部在非叶级中。在聚簇索引中，表中的数据所在的数据页是叶级，在叶级之上的索引页是非叶级，索引数据所在的索引页是非叶级。

在聚簇索引中，数据 值的顺序总是按照**升序排列**。应该在表中经常搜索的列或者按照顺序访问的列上创建聚簇索引。

当创建聚簇索引时，应该考虑这些因素：

1. 每一个表只能 有一个聚簇索引，因为表中行的物理顺序和索引中行的物理顺序是相同的
2. 在创建任何非聚簇索引之前创建聚簇索引，这是因为聚簇索引改变了表中行的物理顺序，数据行按照一定的顺序排列，并且自动维护这个顺序；
3. 关键值的唯一性要么使用UNIQUE关键字明确维护，要么由一个内部的 唯一标识符明确维护，这些唯一性标识符是系统自己使用的，用户不能访问；
4. 聚簇索引的平均大小大约是数据表的百分之五
5. 有大量重复值、且经常有范围查询（ > ,< ，> =,< =）和order by、group by发生的列，可考  虑建立群集索引； 
6. 组合索引要尽量使关键查询形成索引覆盖，其前导列一定是使用最频繁的列。索引虽有助于提高性能但不是索引越多越好，恰好相反过多的索引会导致系统低效。用户在表中每加进一个索引，维护索引集合就要做相应的更新工作。 

## 1.8 非聚簇索引的体系结构 

在非聚簇索引中，叶级仅包含关键值，而没有包含数据行。非聚簇索引表示行的逻辑顺序。

非聚簇索引有两种体系结构:

### 1.8.1 在没有聚簇索引的表上索引

如果一个数据表中没有聚簇索引，那么这个数据表也称为数据堆。

当非聚簇索引在数据堆的顶部创建时，系统使用索引页中的行标识符指向数据页中的记录。行标识符 存储了数据所在位置的信息。数据堆是通过使用索引分配图（IAM）页来维护的。IAM页包含了数据堆所在簇的存储信息。在系统表sysindexes中， 有一个指针指向了与数据堆相关的第一个IAM页。系统使用IAM页在数据堆中浏览和寻找可以插入新的记录行的空间。这些数据页和在这些数据页中的记录没有 任何的顺序并且也没有链接在一起。在这些数据页之间的唯一的连接是IAM中记录的顺序。当在数据堆上创建了非聚簇索引时，叶级中包含了指向数据页的行标识 符。行标识符指定记录行的逻辑顺序，由文件ID、页号和行ID组成。这些行的标识符维持唯一性。非聚簇索引的叶级页的顺序不同于表中数据的物理顺序。这些 关键值在叶级中以升序维持。 

### 1.8.2 在有聚簇索引的表上创建索引

聚簇键存储了数据的位置信 息。如果某一个表有聚簇索引，那么非聚簇索引的叶级包含了映射到聚簇键的聚簇键值，而不是映射到物理的行标识符。当系统访问有非聚簇索引的表中数据时，并 且这种非聚簇索引创建在聚簇索引上，那么它首先从非聚簇索引来找到指向聚簇索引的指针，然后通过使用聚簇索引来找到数据。 

 