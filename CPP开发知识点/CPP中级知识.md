引用网址: https://blog.csdn.net/ac540101928/article/details/52381805

# 1. 编译后程序的内存布局

## 1.1 C/C++ 内存布局

一个经过编译的C/C++的程序占用的内存分成以下几个部分：

1. 栈区（stack）：

   由编译器自动分配和释放 ，存放函数的参数值、局部变量的值等，甚至函数的调用过程都是用栈来完成。其操作方式类似于数据结构中的栈。

2. 堆区（heap） ：

   一般由程序员手动申请以及释放， **若程序员不释放，程序结束时可能由OS回收 **。注意它与数据结构中的堆是两回事，分配方式类似于链表。

3. 全局区（静态区）（static）：

   **全局变量**和**静态变量**的存储是放在一块的，**初始化的**全局变量和静态变量在一块区域， **未初始化的**全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放空间。

4. 文字常量区：

   常量字符串就是放在这里的。 程序结束后由系统释放空间。

5. 程序代码区：

   存放函数体的二进制代码。

## 1.2 内存段式管理

目前通用系统（Linux或者Window）多采用段页式内存管理方式，即段式管理与页式管理的组合。每个程序的内存空间分为若干段，进行内存的分配与释放管理；每个段又分为若干页，进行虚拟页与实际页面的映射。段式管理程序以段为单位分配内存，依赖地址映射机制完成段式虚拟地址与实际内存地址的转换。段式管理（程序分段思想）在无OS的嵌入式开发和微系统开发中具有广泛的应用。

* 代码段（code/text segment）

  用来存放执行代码的一块内存区域。该区域的大小在程序运行前就已经确定，并且内存区域属于只读。其中可能包含一些只读的常数变量（如字符串常量）。

* 数据段（data segment）

  * 动态内存分配 : 堆 malloc
  * 静态内存分配
    * 初始化为非零的数据区
    * BSS（Block Started by Symbol）区域一般存放未初始化的全局数据和静态数据

* 栈段（stack segment）

```
int a = 0; 全局初始化区
char *p1; 全局未初始化区
main()
{
    int b; //栈中
    char s[] = "abc"; //栈中
    char *p2; //栈中
    char *p3 = "123456"; //123456/0在常量区，p3在栈上
    static int c =0； //全局（静态）初始化区
    //以下分配得到的10和20字节的区域就在堆区
    p1 = (char *)malloc(10);
    p2 = new char[20];//(char *)malloc(20);
    //123456/0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
    strcpy(p1, "123456"); 
}
```

注意p1本身在全局区，而p2本身是在栈中的，只是它们指向的空间是在堆中。

## 1.3 堆和栈的内存分配方式

### 1.3.1 位置

临时变量, 内部变量,系统栈在栈段中

动态分配在数据段的堆中,

全局,静态变量在数据段的BSS和非零数据区,

### 1.3.2 系统响应

* 栈（stack）:只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 
* 堆（heap）: 首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。

### 1.3.3 申请大小限制

* 栈（stack）:在Windows下,栈是高地址向低地址扩展的数据结构，是一块连续的内存的区域。

  栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M

  打开工程，依次操作菜单如下：Project->Setting->Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。

*  堆是向高地址扩展的数据结构，是不连续的内存区域（空闲部分用链表串联起来）。由系统是用链表来存储空闲内存，而链表的遍历方向是由低地址向高地址。一般来讲在32位系统下，堆内存可以达到4G的空间

### 1.3.4 特殊内容

栈（stack）:在函数调用时，第一个进栈的是主函数中子函数调用后的下一条指令的地址，然后是子函数的各个形参。在大多数的C编译器中，参数是由右往左入栈的，然后是子函数中的局部变量。**注意：静态变量是不入栈的**。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中子函数调用完成的下一条指令，程序由该点继续运行。 

堆（heap）:一般是在堆的头部用一个字节存放堆的大小，堆中的具体内容有程序员安排。

## 1.4 常见错误

1. 内存的申请和分配并没有成功，但程序员却使用了它。 判断指针的值是否为NULL可以有效地避免这种错误
2. 内存的分配已经成功，但是却没有进行初始化就直接使用它了。 主观地认为自己申请的内存的缺省值为0，这样想是没有什么道理的，内存分配后的值是不确定的
3. 申请了内存，使用完了却忘记了释放，导致内存泄露。它会慢慢地吞噬你的系统资源，直到你的程序彻底完蛋
4. 你很小心地释放了内存，但是却又使用了它。由于程序很复杂或者调用顺序出错，这样可能导致出现上面的错误。

# 2 Dll入口函数参数详解

https://blog.csdn.net/friendan/article/details/7659190

DLL程序入口点函数：DllMain，注意：大小写是区别的(仅导出资源的DLL可以没有DllMain函数)。

## 2.1 函数原型:

```cpp
BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    return TRUE;
}
```

### 参数意义:

①hModule参数：指向DLL本身的实例句柄；

②ul_reason_for_call参数：指明了DLL被调用的原因，可以有以下4个取值：

## 2.2 DLL_PROCESS_ATTACH

当DLL被进程 <<第一次>> 调用时，导致DllMain函数被调用，

同时ul_reason_for_call的值为DLL_PROCESS_ATTACH，

如果同一个进程后来再次调用此DLL时，操作系统只会增加DLL的使用次数，

不会再用DLL_PROCESS_ATTACH调用DLL的DllMain函数。

## 2.3 DLL_PROCESS_DETACH：

当DLL被从进程的地址空间解除映射时，系统调用了它的DllMain，传递的ul_reason_for_call值是DLL_PROCESS_DETACH。
★如果进程的终结是因为调用了TerminateProcess，系统就不会用DLL_PROCESS_DETACH来调用DLL的DllMain函数。这就意味着DLL在进程结束前没有机会执行任何清理工作。

## 2.4 DLL_THREAD_ATTACH：

当进程创建一线程时，系统查看当前映射到进程地址空间中的所有DLL文件映像，

并用值DLL_THREAD_ATTACH调用DLL的DllMain函数。 

新创建的线程负责执行这次的DLL的DllMain函数，

只有当所有的DLL都处理完这一通知后，系统才允许线程开始执行它的线程函数。

## 2.5 DLL_THREAD_DETACH：

如果线程调用了ExitThread来结束线程（线程函数返回时，系统也会自动调用ExitThread），

系统查看当前映射到进程空间中的所有DLL文件映像，

并用DLL_THREAD_DETACH来调用DllMain函数，

通知所有的DLL去执行线程级的清理工作。

★注意：如果线程的结束是因为系统中的一个线程调用了TerminateThread，

系统就不会用值DLL_THREAD_DETACH来调用所有DLL的DllMain函数。

